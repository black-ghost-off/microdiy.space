<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>microdiy.space</title>
    <link>/</link>
    <description>microdiy.space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ua-ua</language>
    <lastBuildDate>Fri, 26 Jul 2024 11:03:02 +0300</lastBuildDate>
    
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Дебаг Serial порта(сніфінг)</title>
      <link>/posts/debug-serial-port/</link>
      <pubDate>Fri, 26 Jul 2024 11:03:02 +0300</pubDate>
      
      <guid>/posts/debug-serial-port/</guid>
      <description>&lt;h2 id=&#34;вступ&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d0%b2%d1%81%d1%82%d1%83%d0%bf&#34;&gt;
        #
    &lt;/a&gt;
    Вступ
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;Треба інколи дебажити(сніфити) що там якась апка каже серіал порту і проводити реверс інженеринг того всього. Найпростіше що спадає на думку це взяти логічний аналізатор і аналізувати те що бігає по проводках, а краще осцилограф&amp;hellip;&lt;/p&gt;
&lt;p&gt;Це такий собі варіант коли в нас попросту немає куди під&amp;rsquo;єднатися, або в девайсі тільки usb і максимально не хочеться паятися, розбирати то, або в нас RS232 12V і логічні аналізатори те не андерстуд(згорить нафіг). Тому сьогодні гайд для Windows як то аналізувати(у Linux це теж поможе там потрібно юзати socat, або tty0tty), не виходячи з-за компа.&lt;/p&gt;
&lt;h2 id=&#34;що-нам-потрібно&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d1%89%d0%be-%d0%bd%d0%b0%d0%bc-%d0%bf%d0%be%d1%82%d1%80%d1%96%d0%b1%d0%bd%d0%be&#34;&gt;
        #
    &lt;/a&gt;
    Що нам потрібно?
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;Потрібно звантажити та встановити Virtual Serial Port Tools
&lt;img src=&#34;https://microdiy.space/images/virtual-serial-port-tools.png&#34; alt=&#34;alt&#34;&gt;
Так ця апка виглядає в середині і що вона дозволяє робити?
Створювати віртуальні Serial COM порти які з&amp;rsquo;єднані між собою.&lt;/p&gt;
&lt;h4 id=&#34;навіщо&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d0%bd%d0%b0%d0%b2%d1%96%d1%89%d0%be&#34;&gt;
        ###
    &lt;/a&gt;
    Навіщо?
&lt;/div&gt;
&lt;/h4&gt;
&lt;p&gt;Нижче наведено кейси з якими можна використовувати цю апку.
&lt;img src=&#34;https://microdiy.space/images/virtual-serial-port-tools-cases.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;Якщо в Linux під python є спеціальна бібліотека (&lt;a href=&#34;https://github.com/ezramorris/PyVirtualSerialPorts&#34;&gt;LINK&lt;/a&gt;) то в нашому випадку з Windows і python не може так просто взяти і створити віртуальний порт. Тому любимось як можемо.&lt;/p&gt;
&lt;h2 id=&#34;що-робити&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d1%89%d0%be-%d1%80%d0%be%d0%b1%d0%b8%d1%82%d0%b8&#34;&gt;
        #
    &lt;/a&gt;
    Що робити?
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/device-manager-COM-ports.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Качаємо мою апку за &lt;a href=&#34;https://github.com/black-ghost-off/serial-port-logger&#34;&gt;посиланням&lt;/a&gt; яка буде якраз таки логувати все в CSV файл в любому зручному вам форматі(ASCII, BIN, HEX), який ви потім якось відкриєте і будете аналізувати.&lt;/li&gt;
&lt;li&gt;Качаємо Virtual Serial Port Tools(гугля допомже).&lt;/li&gt;
&lt;li&gt;Налаштовуємо bridge як показано в першій картинці. (COM* &amp;lt;-&amp;gt; COM*).&lt;/li&gt;
&lt;li&gt;Підключаємось апкою одним кінцем до справжнього COM порта(наприклад в мене це COM18), а іншим до одного з віртуальних портів(наприклад до COM10).&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;python COMLogger.py --real COM18 --virt COM10 --baud &lt;span style=&#34;color:#ff9f43&#34;&gt;115200&lt;/span&gt; --mode hex
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Підключаємось додатком який має спілкуватися з вашим девайсом(наприклад Arduino Monitor).&lt;/li&gt;
&lt;li&gt;Done.
&lt;img src=&#34;https://microdiy.space/images/serial-logger-csvexample.png&#34; alt=&#34;alt&#34;&gt;
Тепер сидимо і аналізуємо)&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Робимо з клона майже оригінал (stlinkv2)</title>
      <link>/posts/stm32-stlink-clone/</link>
      <pubDate>Wed, 26 Jun 2024 10:56:30 +0300</pubDate>
      
      <guid>/posts/stm32-stlink-clone/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Гарний інструмент коштує дорого&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;хейт-спіч-вступ&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d1%85%d0%b5%d0%b9%d1%82-%d1%81%d0%bf%d1%96%d1%87-%d0%b2%d1%81%d1%82%d1%83%d0%bf&#34;&gt;
        ##
    &lt;/a&gt;
    Хейт спіч (вступ)
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;В випадку з оригінальними девкітами, дебагерами, програматорами це інколи дуже гарні гроші, прям дуже
Тому в роки студентства я не міг собі дозволити оригінальний St Link V2 і тому довгий час возився з свистками з не зрозумілими клонами stm32f103**** в середині, що мені коштували не один нейрончик спалений в моїй голові.&lt;/p&gt;
&lt;p&gt;Після десятка годин роботи з неякісними клонами я вирішив взяти себе в руки і купити оригінальний, красивий StLink V2
&lt;img src=&#34;https://microdiy.space/images/stlinkv2Clone1.jpg&#34; alt=&#34;alt&#34;&gt;
&lt;img src=&#34;https://microdiy.space/images/mb936_internal-front2.jpg&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;І все було б добре, якби це був оригінал&amp;hellip;
Проблема виникла в дуже не приємний момент. Коли мені скидають бінарнік для прошивки плати, я підключаюсь STM32CubeProgrammer і ніби все добре, а плата не підключається, заходжу в STM32CubeIDE, прошиваю звідти прошивкою - Все ок, починаю дебажити - Все ок&amp;hellip; А програмер працювати не хоче(&lt;/p&gt;
&lt;p&gt;Трохи почухав голову, згадав що міняв версію прошивки і після цьогоооо замість Serial Number, в мене буковка T появилась&amp;hellip; А потім я ще перепрошивав з ST-LinkV2 на J-Link (треба було для NRF терміново програматор, а нічого більше не було під рукою) і тоді нічого не працювало&amp;hellip; І тут мене почали кусати думки що походу це не оригінал&amp;hellip;&lt;/p&gt;
&lt;p&gt;Відкривши кришку я побачив доволі знайомий з студентства &amp;ldquo;geehy apm32f103cbt6&amp;rdquo;. Це не поганий клон stm32, він працює в програматорах, але це клон, клони рідко коли бувають краще, або хоча б такі як оригінал&amp;hellip; Тому я почав думати.&lt;/p&gt;
&lt;p&gt;Мені треба &amp;ldquo;оригінальний&amp;rdquo; і робочий інструмент.&lt;/p&gt;
&lt;h1 id=&#34;що-треба-робити&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d1%89%d0%be-%d1%82%d1%80%d0%b5%d0%b1%d0%b0-%d1%80%d0%be%d0%b1%d0%b8%d1%82%d0%b8&#34;&gt;
        ##
    &lt;/a&gt;
    Що треба робити?
&lt;/div&gt;
&lt;/h1&gt;
&lt;p&gt;Цей програматор працює з STM32 Utility(примітка, ті МК з якими я працюю не працюють ВЖЕ з цією апкою, вона актуальна під старі чіпи) тому зашити через неї в оригінальний STM32F103C8T6 якусь прошивку не складе великої проблеми.&lt;/p&gt;
&lt;p&gt;Беремо Bluepill&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/stm32bluepill.jpg&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;І зашиваємо &lt;a href=&#34;https://github.com/open-plc-com/firmwares/blob/master/STM32F103C8T6/ST-Link/STLinkV2.J16.S4.bin&#34;&gt;&lt;em&gt;firmware&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Наступний етап най противніший, переставляємо замість &lt;em&gt;geehy&lt;/em&gt; stm32f103c8t6, по розпіновці вони абсолютно pin to pin.&lt;/p&gt;
&lt;p&gt;Після вдалої трансплантації в вас повністю робочий StLink V2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/stm32_cube_programmer.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;Після цих маніпуляцій можна провести firmware upgrade і користуватися як вам потрібно як звичайним STLINK програматором.&lt;/p&gt;
&lt;p&gt;Розпіновка SWD зберігається. JTAG не користуюсь, за нього не ручаюсь.
&lt;img src=&#34;https://microdiy.space/images/stlinkv2pinout.jpg&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;В теорії китайські свистки з цим же камушком теж можна переробити під &amp;ldquo;оригінальний&amp;rdquo; програматор.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/stlinkv2Clone2.jpg&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grafana Ploter</title>
      <link>/posts/grafana-ploter/</link>
      <pubDate>Sun, 12 May 2024 00:20:25 +0300</pubDate>
      
      <guid>/posts/grafana-ploter/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/avocado_monitoring11.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;вступ&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d0%b2%d1%81%d1%82%d1%83%d0%bf&#34;&gt;
        #
    &lt;/a&gt;
    Вступ
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;Візуалізація даних від різних пристроїв як, наприклад Arduino, ESP, STM завжди мало певні проблеми через не велику кількість Real-Time плотерів які можуть візуалізувати різні дані в різних в різні красиві графіки. З приходом Grafana в середовищі DiY точилось багато запитань, а як на цій самій графані візуалізувати дані?&lt;/p&gt;
&lt;p&gt;Почнім с того що з самого початку Grafana будувалась для аналітики та інтерактивної візуалізації(грошей, навантажень на сервері, кількість запитів, продажів тощо&amp;hellip;), для Real-Time націленості не було з самого початку, та все змінилось в 2021, коли була додана підтримка візуалізації даних в реальному часі для IoT. Сьогодні ми розглянемо кейси саме для IoT та для «безінтернетних речей».&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Grafana — це мультиплатформенний веб-додаток для аналітики та інтерактивної візуалізації з відкритим кодом. Він надає діаграми, графіки та сповіщення для Інтернету при підключенні до підтримуваних джерел даних.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Як піднімати сервер, встановлювати/налаштовувати софт, як написати прошивку під ваш пристрій я розглядати не буду!&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;mqtt&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#mqtt&#34;&gt;
        #
    &lt;/a&gt;
    MQTT
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/mqtt-architecture.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;MQTT — спрощений мережевий протокол, що працює на TCP/IP. Використовується для обміну повідомленнями між пристроями за принципом видавець-підписник.&lt;/p&gt;
&lt;p&gt;Цей спосіб потребує для своєї реалізації доступ до інтернетів нашого пристрою(це може бути ESP32, raspberry pi, або якась нова Arduino UNO R4/arduino portenta h7), MQTT сервер(будь-який пристрій з linux/windows/MacOS, на який встановлено MQTT брокер), сама Grafana, influxDB(опціонально), telegraf(опціонально).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/blobid0_rCq5RJB.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;На малюнку зображено два кейси з використанням MQTT, але нащо? Річ у тому що ні Grafana, ні MQTT не вміють зберігати логи про те які дані бігали, між ними потрібно якась база даних якщо вам потрібно дивитися на дані через якийсь період часу. Базою даних може виступати абсолютно люба DB, проте Good Practice для графани є використання InluxDB та Telegraf(є куча статей на цю тему).&lt;/p&gt;
&lt;p&gt;У випадку коли в нас джерелом даних виступає MQTT ми знаємо про дані які прибігли в Grafana до моменту перезавантаження сторінки.&lt;/p&gt;
&lt;h2 id=&#34;serial--websocket&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#serial--websocket&#34;&gt;
        #
    &lt;/a&gt;
    Serial &amp;lt;=&amp;gt; WebSocket
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;А як бути з НЕ інтернет девайсами? Припустімо що графану ми поставили собі на локальний комп’ютер, під’єднали плату Arduino, якось її там запрограмували та тепер їх потрібно пов’язати між собою.&lt;/p&gt;
&lt;p&gt;Для цього приходить на допомогу утиліта яку я написав &lt;a href=&#34;https://github.com/black-ghost-off/WebSocket_Serial_Converter&#34;&gt;WebSocket Serial Converter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://microdiy.space/images/diagram.png&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;p&gt;В цьому кейсі усякий комп’ютер виступає проміжною одиницею між графаною, та якимось девайсом, або, між іншим комп’ютером (бразузером) та нашим девайсом. Як в кейсі з MQTT, без InfluxDB, цей спосіб не вміє на довго зберігати інформацію про те яка інформація була згенерована нашим пристроєм.&lt;/p&gt;
&lt;h2 id=&#34;висновок&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#%d0%b2%d0%b8%d1%81%d0%bd%d0%be%d0%b2%d0%be%d0%ba&#34;&gt;
        #
    &lt;/a&gt;
    Висновок
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;Grafana — це потужний інструмент для візуалізації даних, який може бути використаний як для IoT, так і для DIY, та інших пристроїв.&lt;/p&gt;
&lt;p&gt;Для пристроїв, які мають доступ до Інтернету, найкращий варіант це використання протоколу MQTT та бази даних InfluxDB, який дозволяє в реальному часі візуалізувати дані та забезпечує можливість аналізу старих подій.&lt;/p&gt;
&lt;p&gt;У випадках, коли пристрої не мають доступу до Інтернету, використання Serial &amp;lt;=&amp;gt; WebSocket надає можливість зв’язку між пристроєм та Grafana через локальний комп’ютер.&lt;/p&gt;
&lt;p&gt;Загалом, вибір між цими підходами залежить від конкретних умов проєкт, доступності Інтернету та вимог до аналізу та візуалізації даних. Grafana відкриває широкі можливості для розробників IoT-проектів та тих, хто працює з «безінтернетними речами».&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My First Post</title>
      <link>/posts/my-first-post/</link>
      <pubDate>Fri, 10 May 2024 14:53:12 +0300</pubDate>
      
      <guid>/posts/my-first-post/</guid>
      <description>&lt;h2 id=&#34;introduction&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#introduction&#34;&gt;
        #
    &lt;/a&gt;
    Introduction
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;This is &lt;strong&gt;bold&lt;/strong&gt; text, and this is &lt;em&gt;emphasized&lt;/em&gt; text.&lt;/p&gt;
&lt;p&gt;Visit the &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; website!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
